"use client";

import Fuse from 'fuse.js';
import type { FuseResultMatch } from 'fuse.js';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import VirtualList from 'rc-virtual-list';
import ModuleCard from '../components/ModuleCard';
import Meta from '../components/SEO/Meta';
import modules, { ModuleMetadata } from '../modules/metadata';

type ModuleSearchResult = {
  item: ModuleMetadata;
  matches?: readonly FuseResultMatch[];
  score?: number;
};

type ModuleSearchResultWithIndex = ModuleSearchResult & { index: number };

export default function PostExploitation() {
  const [query, setQuery] = useState('');
  const [selected, setSelected] = useState<ModuleMetadata | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [activeIndex, setActiveIndex] = useState<number>(0);

  const transcript = `meterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter > keyscan_start\nStarting the keystroke sniffer...\nmeterpreter > run persistence_service\n[*] Creating service accomplished\n`;

  const copyTranscript = () => {
    navigator.clipboard?.writeText(transcript);
  };

  const allTags = Array.from(new Set(modules.flatMap((m) => m.tags))).sort();

  const fuse = useMemo(
    () =>
      new Fuse(modules, {
        includeMatches: true,
        threshold: 0.35,
        ignoreLocation: true,
        keys: [
          { name: 'name', weight: 0.6 },
          { name: 'description', weight: 0.3 },
          { name: 'tags', weight: 0.1 },
        ],
      }),
    []
  );

  const searchResults = useMemo<ModuleSearchResult[]>(() => {
    const trimmed = query.trim();
    if (!trimmed) {
      return modules.map((module) => ({ item: module }));
    }

    return fuse.search(trimmed, { limit: modules.length }).map((result) => ({
      item: result.item,
      matches: result.matches,
      score: result.score,
    }));
  }, [fuse, query]);

  const filteredResults = useMemo<ModuleSearchResult[]>(() => {
    if (selectedTags.length === 0) {
      return searchResults;
    }

    return searchResults.filter((result) =>
      result.item.tags.some((tag) => selectedTags.includes(tag))
    );
  }, [searchResults, selectedTags]);

  useEffect(() => {
    if (filteredResults.length === 0) {
      setActiveIndex(-1);
      setSelected((prev) => (prev ? null : prev));
      return;
    }

    setActiveIndex((prev) => {
      if (prev < 0) return 0;
      if (prev >= filteredResults.length) {
        return filteredResults.length - 1;
      }
      return prev;
    });

    setSelected((prev) => {
      if (!prev) return prev;
      const stillExists = filteredResults.some(
        (result) => result.item.name === prev.name
      );
      if (stillExists) {
        return prev;
      }
      return filteredResults[0]?.item ?? null;
    });
  }, [filteredResults]);

  const handleKeyDown = useCallback(
    (event: React.KeyboardEvent<HTMLInputElement>) => {
      if (!filteredResults.length) {
        return;
      }

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        setActiveIndex((prev) => {
          if (prev < 0) return 0;
          return Math.min(prev + 1, filteredResults.length - 1);
        });
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        setActiveIndex((prev) => {
          if (prev <= 0) {
            return 0;
          }
          return prev - 1;
        });
      } else if (event.key === 'Enter') {
        if (activeIndex >= 0 && activeIndex < filteredResults.length) {
          event.preventDefault();
          const next = filteredResults[activeIndex].item;
          setSelected(next);
        }
      }
    },
    [activeIndex, filteredResults]
  );

  const resultsWithIndex = useMemo<ModuleSearchResultWithIndex[]>(
    () =>
      filteredResults.map((result, index) => ({
        ...result,
        index,
      })),
    [filteredResults]
  );

  const toggleTag = (tag: string) => {
    setSelectedTags((prev) =>
      prev.includes(tag) ? prev.filter((t) => t !== tag) : [...prev, tag]
    );
  };

  return (
    <>
      <Meta />
      <main className="mx-auto grid gap-4 p-4 md:grid-cols-2">
        <section className="prose">
          <h1>Metasploit Post-Exploitation Modules</h1>
          <p>
            Post-exploitation refers to any actions taken after a session is opened. Rapid7&apos;s{' '}
            <a
              href="https://docs.rapid7.com/metasploit/about-post-exploitation/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Metasploit documentation
            </a>{' '}
            explains that these modules run on an active session to help operators gather deeper
            information, escalate privileges, pivot within the network, or maintain persistence.
          </p>
          <input
            type="text"
            placeholder="Search modules..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
            aria-label="Search modules"
            className="mb-4 w-full rounded border p-2"
          />
          <div className="mb-4 flex flex-wrap gap-2">
            {allTags.map((tag) => {
              const checkboxId = `module-tag-${tag.replace(/\s+/g, '-')}`;
              return (
                <div key={tag} className="flex items-center space-x-1">
                  <input
                    id={checkboxId}
                    type="checkbox"
                    checked={selectedTags.includes(tag)}
                    onChange={() => toggleTag(tag)}
                    aria-label={tag}
                    className="rounded"
                  />
                  <label htmlFor={checkboxId} className="cursor-pointer">
                    {tag}
                  </label>
                </div>
              );
            })}
          </div>
          {resultsWithIndex.length === 0 ? (
            <p>No modules match your search.</p>
          ) : (
            <VirtualList
              data={resultsWithIndex}
              height={600}
              itemHeight={120}
              itemKey={(result) => result.item.name}
              component="ul"
              className="grid gap-4 list-none p-0"
            >
              {(result: ModuleSearchResultWithIndex) => (
                <li key={result.item.name}>
                  <ModuleCard
                    module={result.item}
                    onSelect={(module) => {
                      setSelected(module);
                      setActiveIndex(result.index);
                    }}
                    selected={
                      selected?.name === result.item.name ||
                      result.index === activeIndex
                    }
                    query={query.trim()}
                    matches={result.matches}
                  />
                </li>
              )}
            </VirtualList>
          )}
        </section>
        <aside className="prose">
          {selected ? (
            <>
              <h2>{selected.name}</h2>
              <p>{selected.description}</p>
              <h3>Options</h3>
              <ul>
                {selected.options.map((opt) => (
                  <li key={opt.name}>
                    <strong>{opt.name}</strong>{' '}
                    {opt.required ? '(required)' : '(optional)'} - {opt.description}
                  </li>
                ))}
              </ul>
            </>
          ) : (
            <p>Select a module to view details.</p>
          )}
          <h3>Example Transcript</h3>
          <div className="flex items-start gap-2">
            <pre className="flex-1 overflow-x-auto rounded bg-black p-3 text-green-400 font-mono">
              {transcript}
            </pre>
            <button
              onClick={copyTranscript}
              className="px-2 py-1 text-sm rounded bg-gray-700"
            >
              Copy
            </button>
          </div>
        </aside>
      </main>
    </>
  );
}

