'use client';

import React, { useEffect, useId, useMemo, useState } from 'react';
import Modal from '../base/Modal';

export type PermissionKey = 'filesystem' | 'notifications' | 'storage';
export type PermissionStatus = 'granted' | 'denied' | 'prompt' | 'unsupported';

export type PermissionSnapshot = Record<PermissionKey, PermissionStatus>;

interface PermissionPromptProps {
  isOpen: boolean;
  onClose: () => void;
  onResolved: (permissions: PermissionSnapshot) => void;
  /**
   * Pre-populated statuses. Useful when re-opening the prompt with
   * remembered selections.
   */
  initialState?: Partial<PermissionSnapshot>;
}

interface InternalPermissionState {
  status: PermissionStatus;
  remember: boolean;
  error?: string;
}

interface PermissionDefinition {
  key: PermissionKey;
  label: string;
  description: string;
  learnMore?: string;
}

const STORAGE_KEY = 'extension-permission-decisions';

const PERMISSION_DEFINITIONS: PermissionDefinition[] = [
  {
    key: 'filesystem',
    label: 'File system access',
    description:
      'Allow extensions to read and save files within the sandboxed workspace used by the portfolio demos.',
    learnMore:
      'Needed to import or export data packs and to persist files generated by simulated security tooling.',
  },
  {
    key: 'notifications',
    label: 'Desktop notifications',
    description:
      'Let extensions send completion and alert banners while they finish background processing.',
    learnMore:
      'These are only used for local feedback – no external notifications are sent.',
  },
  {
    key: 'storage',
    label: 'Persistent storage',
    description:
      'Keep installed extensions and their last run history saved between sessions.',
    learnMore:
      'Without this permission, everything resets when the window closes.',
  },
];

const STATUS_LABEL: Record<PermissionStatus, string> = {
  granted: 'Allowed',
  denied: 'Blocked',
  prompt: 'Needs review',
  unsupported: 'Not supported',
};

const STATUS_CLASS: Record<PermissionStatus, string> = {
  granted: 'text-ub-green',
  denied: 'text-ub-orange',
  prompt: 'text-ub-yellow',
  unsupported: 'text-gray-400',
};

const PERMISSION_KEYS: PermissionKey[] = ['filesystem', 'notifications', 'storage'];

export const loadRememberedPermissions = (): Partial<PermissionSnapshot> => {
  if (typeof window === 'undefined') {
    return {};
  }
  try {
    const raw = window.localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      return {};
    }
    const parsed = JSON.parse(raw) as Partial<PermissionSnapshot>;
    const sanitized: Partial<PermissionSnapshot> = {};
    for (const key of PERMISSION_KEYS) {
      const value = parsed?.[key];
      if (value === 'granted' || value === 'denied' || value === 'unsupported') {
        sanitized[key] = value;
      }
    }
    return sanitized;
  } catch {
    return {};
  }
};

const persistRememberedPermissions = (snapshot: Partial<PermissionSnapshot>) => {
  if (typeof window === 'undefined') {
    return;
  }
  try {
    if (Object.keys(snapshot).length === 0) {
      window.localStorage.removeItem(STORAGE_KEY);
    } else {
      window.localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
    }
  } catch {
    // Storage might be unavailable – ignore and keep the in-memory values.
  }
};

const detectFilesystemSupport = () =>
  typeof window !== 'undefined' &&
  (typeof (window as unknown as { showDirectoryPicker?: unknown }).showDirectoryPicker === 'function' ||
    typeof (window as unknown as { chooseFileSystemEntries?: unknown }).chooseFileSystemEntries === 'function');

const detectNotificationSupport = () => typeof window !== 'undefined' && 'Notification' in window;

const detectStorageSupport = () =>
  typeof navigator !== 'undefined' && !!navigator.storage && typeof navigator.storage.persist === 'function';

const createInitialState = (
  base?: Partial<PermissionSnapshot>,
): Record<PermissionKey, InternalPermissionState> => ({
  filesystem: {
    status: base?.filesystem ?? 'prompt',
    remember: base?.filesystem !== undefined,
  },
  notifications: {
    status: base?.notifications ?? 'prompt',
    remember: base?.notifications !== undefined,
  },
  storage: {
    status: base?.storage ?? 'prompt',
    remember: base?.storage !== undefined,
  },
});

const PermissionPrompt: React.FC<PermissionPromptProps> = ({
  isOpen,
  onClose,
  onResolved,
  initialState,
}) => {
  const headingId = useId();
  const descriptionId = useId();
  const [state, setState] = useState<Record<PermissionKey, InternalPermissionState>>(() =>
    createInitialState(initialState),
  );

  useEffect(() => {
    if (isOpen) {
      setState(createInitialState(initialState));
    }
  }, [isOpen, initialState]);

  useEffect(() => {
    if (!isOpen) {
      return;
    }
    setState((prev) => ({
      ...prev,
      filesystem: detectFilesystemSupport()
        ? prev.filesystem
        : { ...prev.filesystem, status: 'unsupported', remember: false },
      notifications: detectNotificationSupport()
        ? prev.notifications
        : { ...prev.notifications, status: 'unsupported', remember: false },
      storage: detectStorageSupport() ? prev.storage : { ...prev.storage, status: 'unsupported', remember: false },
    }));
  }, [isOpen]);

  const isActionDisabled = useMemo(() => {
    return PERMISSION_KEYS.some((key) => {
      const status = state[key].status;
      return status === 'prompt';
    });
  }, [state]);

  const handleAllow = async (key: PermissionKey) => {
    if (key === 'filesystem') {
      if (!detectFilesystemSupport()) {
        setState((prev) => ({
          ...prev,
          filesystem: {
            ...prev.filesystem,
            status: 'unsupported',
            error: 'The browser does not support the File System Access API yet.',
          },
        }));
        return;
      }
      try {
        if (typeof (window as unknown as { showDirectoryPicker?: () => Promise<unknown> }).showDirectoryPicker === 'function') {
          await (window as unknown as { showDirectoryPicker: () => Promise<unknown> }).showDirectoryPicker();
        } else if (
          typeof (window as unknown as { chooseFileSystemEntries?: () => Promise<unknown> }).chooseFileSystemEntries === 'function'
        ) {
          await (window as unknown as { chooseFileSystemEntries: () => Promise<unknown> }).chooseFileSystemEntries();
        }
        setState((prev) => ({
          ...prev,
          filesystem: { ...prev.filesystem, status: 'granted', error: undefined },
        }));
      } catch (error) {
        const domError = error as DOMException;
        const status = domError?.name === 'AbortError' ? 'prompt' : 'denied';
        setState((prev) => ({
          ...prev,
          filesystem: {
            ...prev.filesystem,
            status,
            error: status === 'denied' ? 'Access to the sandboxed workspace was declined.' : undefined,
          },
        }));
      }
      return;
    }

    if (key === 'notifications') {
      if (!detectNotificationSupport()) {
        setState((prev) => ({
          ...prev,
          notifications: {
            ...prev.notifications,
            status: 'unsupported',
            error: 'Notifications are not available in this browser.',
          },
        }));
        return;
      }
      try {
        const result = await Notification.requestPermission();
        setState((prev) => ({
          ...prev,
          notifications: {
            ...prev.notifications,
            status: result === 'granted' ? 'granted' : result === 'denied' ? 'denied' : 'prompt',
            error: result === 'denied' ? 'Notifications will stay inside the window only.' : undefined,
          },
        }));
      } catch {
        setState((prev) => ({
          ...prev,
          notifications: {
            ...prev.notifications,
            status: 'denied',
            error: 'The request for notifications failed.',
          },
        }));
      }
      return;
    }

    if (key === 'storage') {
      if (!detectStorageSupport()) {
        setState((prev) => ({
          ...prev,
          storage: {
            ...prev.storage,
            status: 'unsupported',
            error: 'Persistent storage is unavailable in this environment.',
          },
        }));
        return;
      }
      try {
        const persisted = await navigator.storage.persist();
        setState((prev) => ({
          ...prev,
          storage: {
            ...prev.storage,
            status: persisted ? 'granted' : 'denied',
            error: persisted ? undefined : 'Data will reset when the tab closes.',
          },
        }));
      } catch {
        setState((prev) => ({
          ...prev,
          storage: {
            ...prev.storage,
            status: 'denied',
            error: 'Failed to request persistent storage.',
          },
        }));
      }
    }
  };

  const handleDeny = (key: PermissionKey) => {
    setState((prev) => ({
      ...prev,
      [key]: {
        ...prev[key],
        status: 'denied',
        error:
          key === 'storage'
            ? 'Data will reset when the tab closes.'
            : key === 'filesystem'
            ? 'Extensions will not be able to export files.'
            : 'Notifications will stay inside the window only.',
      },
    }));
  };

  const toggleRemember = (key: PermissionKey, remember: boolean) => {
    setState((prev) => ({
      ...prev,
      [key]: {
        ...prev[key],
        remember,
      },
    }));
  };

  const handleConfirm = () => {
    const snapshot = PERMISSION_KEYS.reduce<PermissionSnapshot>((acc, key) => {
      acc[key] = state[key].status;
      return acc;
    }, {
      filesystem: 'prompt',
      notifications: 'prompt',
      storage: 'prompt',
    });

    onResolved(snapshot);

    const remembered: Partial<PermissionSnapshot> = {};
    PERMISSION_KEYS.forEach((key) => {
      if (state[key].remember && snapshot[key] !== 'prompt') {
        remembered[key] = snapshot[key];
      }
    });
    persistRememberedPermissions(remembered);
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} ariaLabelledBy={headingId} ariaDescribedBy={descriptionId}>
      <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/70 p-4">
        <div className="max-h-[90vh] w-full max-w-2xl overflow-y-auto rounded-lg bg-gray-900 p-6 text-white shadow-xl focus:outline-none focus-visible:ring-2 focus-visible:ring-ub-blue">
          <h2 id={headingId} className="text-2xl font-semibold">
            Review extension permissions
          </h2>
          <p id={descriptionId} className="mt-2 text-sm text-gray-300">
            Each permission keeps the simulated extension environment functional. Choose what to allow and optionally remember
            the decision for next time.
          </p>
          <ul className="mt-6 space-y-4" aria-live="polite">
            {PERMISSION_DEFINITIONS.map((permission) => {
              const item = state[permission.key];
              return (
                <li key={permission.key} className="rounded border border-gray-700 bg-gray-800 p-4">
                  <div className="flex flex-col gap-2 md:flex-row md:items-start md:justify-between">
                    <div>
                      <h3 className="text-lg font-semibold">{permission.label}</h3>
                      <p className="mt-1 text-sm text-gray-300">{permission.description}</p>
                      {permission.learnMore ? (
                        <p className="mt-1 text-xs text-gray-400">{permission.learnMore}</p>
                      ) : null}
                    </div>
                    <p className={`text-sm font-medium ${STATUS_CLASS[item.status]}`}>
                      {STATUS_LABEL[item.status]}
                    </p>
                  </div>
                  {item.error ? (
                    <p className="mt-2 text-sm text-ub-orange" role="status">
                      {item.error}
                    </p>
                  ) : null}
                  <div className="mt-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                    <div className="flex gap-2">
                      <button
                        type="button"
                        onClick={() => void handleAllow(permission.key)}
                        className="rounded bg-ub-blue px-3 py-1 text-sm font-medium text-black disabled:opacity-60"
                        disabled={item.status === 'unsupported'}
                      >
                        Allow
                      </button>
                      <button
                        type="button"
                        onClick={() => handleDeny(permission.key)}
                        className="rounded bg-gray-700 px-3 py-1 text-sm font-medium"
                      >
                        Deny
                      </button>
                    </div>
                    <div className="flex items-center gap-2 text-xs text-gray-300">
                      <input
                        id={`${permission.key}-remember-choice`}
                        type="checkbox"
                        checked={item.remember}
                        onChange={(event) => toggleRemember(permission.key, event.target.checked)}
                        disabled={item.status === 'prompt' || item.status === 'unsupported'}
                        aria-label="Remember this decision"
                      />
                      <label htmlFor={`${permission.key}-remember-choice`} className="cursor-pointer select-none">
                        Remember this decision
                      </label>
                    </div>
                  </div>
                </li>
              );
            })}
          </ul>
          <div className="mt-6 flex flex-col-reverse gap-3 md:flex-row md:justify-end">
            <button
              type="button"
              onClick={onClose}
              className="rounded bg-gray-700 px-4 py-2 text-sm font-medium"
            >
              Cancel
            </button>
            <button
              type="button"
              onClick={handleConfirm}
              disabled={isActionDisabled}
              className="rounded bg-ub-green px-4 py-2 text-sm font-semibold text-black disabled:opacity-60"
            >
              Continue
            </button>
          </div>
        </div>
      </div>
    </Modal>
  );
};

export default PermissionPrompt;
