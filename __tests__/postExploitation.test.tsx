import React from 'react';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';
import PostExploitation from '../pages/post_exploitation';
import { useRouter } from 'next/router';
import { loadMarked } from '../lib/loadMarked';

jest.mock('next/router', () => ({
  useRouter: jest.fn(),
}));

jest.mock('../lib/loadMarked', () => ({
  loadMarked: jest.fn(),
}));

const mockedLoadMarked = loadMarked as jest.MockedFunction<typeof loadMarked>;

const fakeMarked = {
  Renderer: class {
    heading(text: string, level: number) {
      return `<h${level}>${text}</h${level}>`;
    }
  },
  parse: (
    markdown: string,
    options?: { renderer?: { heading?: (text: string, level: number, raw: string) => string } }
  ) => {
    const renderer = options?.renderer;
    return markdown
      .split(/\n+/)
      .filter((line) => line.length > 0)
      .map((line) => {
        const headingMatch = line.match(/^(#{1,6})\s*(.*)$/);
        if (headingMatch && renderer?.heading) {
          const level = headingMatch[1].length;
          const text = headingMatch[2];
          return renderer.heading(text, level, text);
        }
        return `<p>${line}</p>`;
      })
      .join('');
  },
};

const createRouter = (overrides: Partial<ReturnType<typeof useRouter>> = {}) => {
  const router = {
    pathname: '/post_exploitation',
    query: {},
    asPath: '/post_exploitation',
    isReady: true,
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    events: {
      on: jest.fn(),
      off: jest.fn(),
      emit: jest.fn(),
    },
  } as unknown as ReturnType<typeof useRouter> & {
    push: jest.Mock;
    query: Record<string, any>;
    asPath: string;
  };

  Object.assign(router, overrides);

  router.push.mockImplementation(
    (url: { pathname?: string; query?: Record<string, any>; hash?: string }) => {
      if (url.query) {
        router.query = { ...url.query };
      }
      const queryString = url.query
        ? `?${new URLSearchParams(url.query as Record<string, string>).toString()}`
        : '';
      const hash = url.hash ? `#${url.hash}` : '';
      router.asPath = `${url.pathname ?? router.pathname}${queryString}${hash}`;
      return Promise.resolve(true);
    }
  );

  return router;
};

const useRouterMock = useRouter as jest.Mock;

describe('PostExploitation', () => {
  beforeEach(() => {
    mockedLoadMarked.mockResolvedValue({ marked: fakeMarked });
    const router = createRouter();
    useRouterMock.mockReturnValue(router);
  });

  afterEach(() => {
    jest.clearAllMocks();
    jest.restoreAllMocks();
    mockedLoadMarked.mockReset();
  });

  it('filters modules by selected tags', () => {
    render(<PostExploitation />);
    fireEvent.click(screen.getByLabelText('persistence'));
    expect(
      screen.getByRole('button', { name: /persistence_service/i })
    ).toBeInTheDocument();
    expect(
      screen.queryByRole('button', { name: /getsystem/i })
    ).not.toBeInTheDocument();
  });

  it('sanitizes README content and exposes anchor navigation', async () => {
    const router = createRouter();
    useRouterMock.mockReturnValue(router);

    const maliciousMarkdown = `# Demo\n\n## Options\n<script>alert('xss')</script>`;
    const fetchSpy = jest
      .spyOn(global, 'fetch')
      .mockResolvedValue({
        ok: true,
        text: () => Promise.resolve(maliciousMarkdown),
      } as unknown as Response);

    render(<PostExploitation />);

    fireEvent.click(screen.getByRole('button', { name: /getsystem/i }));

    const optionsNav = await screen.findByRole('link', { name: /Options/i });
    expect(optionsNav).toBeInTheDocument();
    expect(document.querySelector('script')).toBeNull();

    fireEvent.click(optionsNav);
    await waitFor(() => {
      expect(router.push).toHaveBeenCalledWith(
        expect.objectContaining({ hash: 'options' }),
        undefined,
        expect.objectContaining({ shallow: true, scroll: false })
      );
    });

    fetchSpy.mockRestore();
  });

  it('scrolls to deep-linked sections when provided via the URL hash', async () => {
    const scrollSpy = jest.fn();
    const originalGetElementById = document.getElementById;
    const getElementSpy = jest
      .spyOn(document, 'getElementById')
      .mockImplementation((id: string): HTMLElement | null => {
        if (id === 'options') {
          return { scrollIntoView: scrollSpy } as unknown as HTMLElement;
        }
        return originalGetElementById.call(document, id);
      });

    const router = createRouter({
      query: { module: 'hashdump' },
      asPath: '/post_exploitation?module=hashdump#options',
    });
    useRouterMock.mockReturnValue(router);

    const fetchSpy = jest
      .spyOn(global, 'fetch')
      .mockResolvedValue({
        ok: true,
        text: () => Promise.resolve('# hashdump\n\n## Options\n- item'),
      } as unknown as Response);

    render(<PostExploitation />);

    await waitFor(() => {
      expect(scrollSpy).toHaveBeenCalled();
    });

    getElementSpy.mockRestore();
    fetchSpy.mockRestore();
  });
});
