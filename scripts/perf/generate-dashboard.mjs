#!/usr/bin/env node
import { readFile, writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.join(__dirname, '..', '..');
const historyPath = path.join(repoRoot, 'e2e', 'perf', 'history.json');
const budgetsPath = path.join(repoRoot, 'e2e', 'perf', 'budgets.json');
const dashboardPath = path.join(repoRoot, 'docs', 'performance-dashboard.md');

const history = JSON.parse(await readFile(historyPath, 'utf-8'));
const budgets = JSON.parse(await readFile(budgetsPath, 'utf-8'));

const metricOrder = ['lcp', 'inp', 'cls', 'memory'];
const header = ['Run', 'Timestamp', 'Git Ref', 'LCP (ms)', 'INP (ms)', 'CLS', 'Memory (MB)'];

const lines = [];
lines.push('# Performance dashboard');
lines.push('');
lines.push('<!-- This file is auto-generated by scripts/perf/generate-dashboard.mjs. -->');
lines.push('<!-- Do not edit manually. Run `yarn perf:report` after updating baselines. -->');
lines.push('');
lines.push(`Last updated: ${new Date().toISOString()}`);
lines.push('');

for (const [scenarioId, scenarioBudget] of Object.entries(budgets.scenarios)) {
  lines.push(`## ${scenarioId}`);
  if (scenarioBudget.description) {
    lines.push(scenarioBudget.description);
    lines.push('');
  }

  lines.push('### Budget');
  for (const metricName of metricOrder) {
    const budget = scenarioBudget.metrics[metricName];
    if (!budget) continue;
    const limit = budget.baseline + budget.maxRegression;
    const formattedBaseline = formatMetric(metricName, budget.baseline);
    const formattedLimit = formatMetric(metricName, limit);
    lines.push(`- **${metricLabel(metricName)}**: baseline ${formattedBaseline}, regression allowance ${formatMetric(metricName, budget.maxRegression)} (limit ${formattedLimit})`);
  }
  lines.push('');

  lines.push('### Historical runs');
  lines.push(`| ${header.join(' | ')} |`);
  lines.push(`| ${header.map(() => '---').join(' | ')} |`);

  const runs = (history.runs || [])
    .filter((run) => run.scenarios && run.scenarios[scenarioId])
    .map((run, index) => ({
      index: index + 1,
      run,
    }));

  if (!runs.length) {
    lines.push('| – | – | – | – | – | – | – |');
  } else {
    runs.forEach(({ index, run }) => {
      const scenarioMetrics = run.scenarios[scenarioId];
      const row = [
        index.toString(),
        new Date(run.timestamp).toISOString(),
        run.gitRef || 'unknown',
        formatMetric('lcp', scenarioMetrics.lcp),
        formatMetric('inp', scenarioMetrics.inp),
        formatMetric('cls', scenarioMetrics.cls),
        formatMetric('memory', scenarioMetrics.memory),
      ];
      lines.push(`| ${row.join(' | ')} |`);
    });
  }

  lines.push('');
}

await writeFile(dashboardPath, `${lines.join('\n')}\n`, 'utf-8');
console.log(`Dashboard written to ${path.relative(repoRoot, dashboardPath)}`);

function formatMetric(metricName, value) {
  const numeric = Number(value ?? 0);
  switch (metricName) {
    case 'cls':
      return numeric.toFixed(3);
    case 'memory':
      return (numeric / (1024 * 1024)).toFixed(1);
    default:
      return Math.round(numeric).toString();
  }
}

function metricLabel(metricName) {
  switch (metricName) {
    case 'lcp':
      return 'Largest Contentful Paint';
    case 'inp':
      return 'Interaction to Next Paint';
    case 'cls':
      return 'Cumulative Layout Shift';
    case 'memory':
      return 'JS Heap';
    default:
      return metricName;
  }
}
