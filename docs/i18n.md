# Internationalization workflow

This project stores translations under `locales/<locale>/<namespace>.json`. Each JSON file is
parsed into a namespace (the file name without the extension) and every nested property becomes a
`dot.separated` translation key. For example, `locales/en/common.json` defines the
`common.clipboard.copied` string that is used by the clipboard live region in `_app.tsx`.

## Auditing translations

Run the audit script locally whenever you add or edit translation files:

```bash
yarn i18n:audit
```

The script loads every JSON file inside `locales/` (or `public/locales/` if you prefer keeping
runtime bundles there), flattens the keys, and compares each locale against the English base
(`I18N_AUDIT_BASE_LOCALE` can override the reference). During local development it logs missing keys
or stale entries and exits successfully so you can fix problems incrementally. In CI the workflow
runs the command with `CI=1`, enabling strict mode so any discrepancy fails the build.

Key behaviours:

- **Missing keys** – when a locale file does not include a key that exists in the base locale, the
  audit logs the missing keys grouped by namespace.
- **Stale keys** – if a locale includes keys that are no longer defined in the base locale, the
  audit flags them so they can be removed or synced.
- **JSON safety** – invalid JSON stops the audit immediately with an error message pointing at the
  file path.

## Runtime fallbacks

The `lib/i18n.ts` helper exposes a `translate` function that reads the compiled translation table.
When a requested locale is missing, the helper logs a warning (deduplicated in development) and
falls back to the English bundle. If the translation key is missing everywhere you can pass a
`fallback` string to `translate`—otherwise the key itself is returned. The clipboard announcements in
`pages/_app.tsx` demonstrate this pattern.

To add translations:

1. Update the base locale file (`locales/en/*.json`) with the new key.
2. Mirror the key in the other locale files, even if you only provide a placeholder string.
3. Run `yarn i18n:audit` and confirm the output is clean before committing.
4. Add unit tests for any new helper behaviour or edge cases when possible.

Keeping the audit clean ensures the new CI step passes and the runtime never silently serves stale
strings.
