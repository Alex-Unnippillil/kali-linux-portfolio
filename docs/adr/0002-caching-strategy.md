# ADR-0002: Caching strategy

- **Status:** Accepted
- **Date:** 2025-02-14
- **Deciders:** Core maintainers
- **Consulted:** Platform engineering
- **Tags:** performance, offline, reliability

## Context

The portfolio ships as a hybrid Next.js experience: statically generated marketing pages, dynamic app windows, and optional API routes for demos. Build-time caching happens automatically through Next.js static generation and dynamic imports. A service worker generated by [`@ducanh2912/next-pwa`](https://github.com/DuCanhGH/next-pwa) precaches assets under `public/`. We need a consistent policy for what gets cached, how offline fallbacks behave, and how contributors extend the strategy without breaking simulations or shipping stale data.

## Decision

- Treat **Next.js static generation** (SSG/ISR) as the primary HTML caching mechanism. Prefer SSG for marketing and documentation pages; use dynamic rendering only when runtime data is required.
- Keep the **service worker scope** limited to static assets in `public/` plus the automatically injected precache manifest. Do not cache API responses or dynamic HTML in the service worker.
- For UI state, rely on **in-memory stores or `localStorage`/`IndexedDB`** in the browser. Avoid custom HTTP caches that could leak sensitive data across sessions.
- Dynamic data such as simulated scan results should be recomputed or replayed from deterministic fixtures instead of being cached long-term.
- When adding new assets, prefer placing them in `public/` so they are precached automatically. Large data files should be lazily fetched via `fetch` with explicit cache headers.
- Document any cache invalidation requirements in release notes and, if necessary, bump the service worker version so clients pick up the new precache list.

## Consequences

- Offline support covers the shell, icons, wallpapers, and deterministic fixtures, ensuring the desktop boots without network access.
- Because API responses are not cached, demos stay accurate and respect feature flags, but users must wait for recomputation on every launch.
- Limiting the caching scope reduces the risk of stale or user-specific data being stored on shared devices.
- Contributors must consciously decide when to store data locally and document the retention behaviour in app-specific docs.

## Implementation Notes

- Verify precache behaviour by running `yarn build` and inspecting `public/sw.js` for newly added assets.
- Use `fetch` with `cache: 'no-store'` for requests that should never be cached by the browser (e.g., telemetry pings, auth tokens).
- If an app needs to preserve data across reloads, leverage existing helpers in `hooks/usePersistentState.ts` which already back onto browser storage APIs.

## Related ADRs

- [ADR-0004](./0004-telemetry-and-analytics.md) â€“ telemetry requests are explicitly excluded from caching.
